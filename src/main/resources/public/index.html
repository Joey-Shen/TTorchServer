<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>TTorch</title>

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/css/bootstrap.min.css"
          integrity="sha384-Smlep5jCw/wG7hdkwQ/Z5nLIefveQRIY9nfy6xoR1uRYBtpZgI6339F5dgvm/e9B" crossorigin="anonymous">
    <link rel="stylesheet" href="http://api.map.baidu.com/library/DrawingManager/1.4/src/DrawingManager_min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.css"/>
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css"
          integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
</head>
<body>
<nav class="nav" >

    <div style="width: 100%; height: 40%; position: relative">
        <img style=" margin-left:88%; margin-top:3px; max-width: 45px; max-height: 35px" src="./img/swipe.png"
             alt="swipe image"/>
        <button style="width: 100%; margin-top: -64px " type="button" class="btn btn-success" disabled>
            Time span
        </button>

        <div class="alert alert-info small" role="alert" style="margin-top: -25px; width: 80%; margin-left: 10%">
            Trajectories are collected during 2018-03-11 11:11:09 to 2018-03-21 11:11:09
        </div>
        <div style="margin-top: -15px; margin-left: 3%" class="small">
            <label for="start_time">from:</label>
            <input type="datetime-local" id="start_time" width="210px"
                   value="2018-03-11T11:11"
                   min="2018-03-11T11:11" max="2018-03-21T11:11" />
        </div>

        <div style="margin-left: 3% "  class="small">
            <label for="end_time">to:</label>
            <input type="datetime-local" id="end_time"
                   value="2018-03-21T11:11" width="210px"
                   min="2018-03-11T11:11" max="2018-03-21T11:11" />
        </div>

        <!-- top k query area -->
        <div style="width: 100%; margin-top: 25px ">
            <button style="width: 100%" type="button" class="btn btn-success" disabled>
                Top K query selector
            </button>

            <div style=" margin-left: 10%; width:80%; margin-top:10px; height: 40%" class="extsmall">
                <div class="input-group mb-3">
                    <div class="input-group-prepend">
                        <span class="input-group-text">Number of results(K): </span>
                    </div>
                    <input type="number" value="15" min="1" max="50" class="form-control"
                           aria-describedby="inputGroup-sizing-sm" id="input_k">
                </div>

                <div class="input-group" id="simWrapper" style="margin-top: 15px;">
                    <div class="input-group-prepend">
                        <span class="input-group-text">Measure</span>
                    </div>

                    <select class="simGroup" id="sim" title="none" onchange="simChange(this.value)">
                        <option value="LORS">LORS</option>
                        <option value="DTW" selected>DTW</option>
                        <option value="LCSS">LCSS</option>
                        <option value="EDR">EDR</option>
                        <option value="H">Hausdorff</option>
                        <option value="F">Fr√©chet</option>
                    </select>

                    <div id="epsilonWrapper" class="input-group mb-3" style="margin-top: 15px; display: none">
                        <div class="input-group-prepend">
                            <span class="input-group-text">Epsilon(LCSS, EDR)</span>
                        </div>
                        <input type="number" value="50" class="form-control"
                               aria-describedby="inputGroup-sizing-sm" id="input_epsilon" style="width: 30px">
                    </div>
                </div>
            </div>

            <div class="clusterize" style="margin-left: 15px">

                <table style="width:100%">
                    <thead>
                    <tr>
                        <td style="width: 105px">Identifier</td>
                        <td style="width: 90px">State</td>
                        <td style="width: 50px">Select</td>
                    </tr>
                    </thead>
                </table>

                <div id="topK_scrollArea" class="clusterize-scroll ">
                    <table style="width:100%" align="center">
                        <tbody id="topK_contentArea" class="clusterize-content">
                        </tbody>
                    </table>
                </div>
            </div>

            <br>
            <button class="btn btn-outline-success" id="sim_search" style="margin-left: 120px" type="button">Search
            </button>

            <button style="width: 100%;" type="button" class="btn btn-success" disabled>
                combined query selector
            </button>
            <br>

            <div class="input-group small" style="margin-left: 20%; width: 60%; margin-top: 15px">
                <input id="input_street" type="text" class="form-control" placeholder="street name"
                       aria-label="street name" aria-describedby="btn_street">
                <div class="input-group-append">
                    <button class="btn btn-outline-secondary" type="button" id="btn_street">add</button>
                </div>
            </div>

            <div class="clusterize" style="margin-top:10px; margin-left: 15px">

                <table style="width:100%">
                    <thead>
                    <tr>
                        <td width="100px">Identifier</td>
                        <td width="80px">State</td>
                        <td width="80px">isStrict</td>
                        <td width="50px">Select</td>
                    </tr>
                    </thead>
                </table>

                <div id="combined_scrollArea" class="clusterize-scroll ">
                    <table style="width: 100%" align="center">
                        <tbody id="combined_contentArea" class="clusterize-content">
                        </tbody>
                    </table>
                </div>
            </div>

            <br>
            <button class="btn btn-outline-success" id="bool_search" style="margin-left: 120px" type="button">Search</button>
        </div>


        <div style=" width: 100%; margin-top: 70px ">
                <div class="retPanel">
                    <button style="margin-top:5px;width: 100%" type="button" class="btn btn-success" disabled>
                        Result Panel <span style="margin-left: 3px" id="retSize" class="badge badge-danger"></span>
                    </button>
                    <div  style="width:100% ; text-align: center">
                        <div class="custom-control custom-checkbox" id="div_showRaw" style="display: none">
                            <input type="checkbox" class="custom-control-input" id="showRaw" checked>
                            <label style="width: 250px" class="custom-control-label" for="showRaw">display raw path</label>
                        </div>
                        <div class="custom-control custom-checkbox" id="div_showMapped" style="display: none">
                            <input type="checkbox" class="custom-control-input" id="showMapped" checked>
                            <label style="width: 250px" class="custom-control-label" for="showMapped">display mapped path</label>
                        </div>

                        <div class="custom-control custom-checkbox" id="div_showRep" style="display: none">
                            <input type="checkbox" class="custom-control-input" id="showRep" checked>
                            <label style="width: 250px" class="custom-control-label" for="showRep">show representative trajectories</label>
                        </div>

                        <div class="custom-control custom-checkbox" id="div_hideRet" style="display: none">
                            <input type="checkbox" class="custom-control-input" id="hideRet" checked>
                            <label style="width: 250px" class="custom-control-label" for="hideRet">hide results</label>
                        </div>
                    </div>
                </div>
                <div class="clusterize">
                    <div id="ret_scrollArea" class="clusterize-scroll ">
                        <ol id="ret_contentArea" class="clusterize-content"
                            style="width: 90%;text-align:center">
                        </ol>
                    </div>
                </div>
                <div class="retPanel" >
                    <div class="progress">
                        <span class="badge badge-secondary">progress</span>
                        <div id="progressBar" class="progress-bar progress-bar-striped" role="progressbar"
                             style="width: 0%; margin-left: 5px" aria-valuenow="0" aria-valuemin="0"
                             aria-valuemax="100"></div>
                    </div>
                </div>
            </div>
    </div>


</nav>

<div style="position:absolute; margin-top: 20px; margin-left: 20px; z-index:3">
    <a href="#" id="btn_nav" class="btn btn-outline-info ssm-toggle-nav"
       style="padding-bottom: 1px; padding-left: 10px; padding-right: 10px; float: left; height: 38px">
        <object id="svg1" data="./img/gear.svg" type="image/svg+xml" style="padding-right: 3px"></object>
        Search Panel
    </a>

    <button class="btn btn-outline-danger" id="btnClear" type="button" style="margin-left: 5px">Clear All</button>
</div>
<div class="dropdown" style="position:absolute; margin-top: 20px; margin-left:45%; z-index: 4 ">
    <button class="btn btn-light dropdown-toggle" type="button" id="cityMenu" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        Dropdown button
    </button>
    <div class="dropdown-menu" aria-labelledby="cityMenu">
        <a class="dropdown-item" href="#" >Beijing</a>
        <a class="dropdown-item" href="#">Porto</a>
    </div>
</div>
<div style="position:absolute; top: 40px; width: 70%; margin-left:15%; margin-right: 15%; z-index:3">
    <div id="info" class="alert alert-warning" role="alert"
         style="height: 45px;position:absolute; z-index:3; margin-top: 25px; margin-left: 25%; margin-right: 25%; width: 55%; font-size: medium; text-align:center; display: none">
    </div>
</div>
<div style=" height: 100%; width: 100%" id="map"></div>
<canvas id="canvas"></canvas>
<a href="https://github.com/tgbnhy/torch-trajectory"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
<!-- JavaScript field -->
<script src="https://code.jquery.com/jquery-3.3.1.js"
        integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
        crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
<script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=o55gGAr8In322oxznMl5cojFABFo5hjE"></script>
<script type="text/javascript"
        src="http://api.map.baidu.com/library/DrawingManager/1.4/src/DrawingManager_min.js"></script>
<script type="text/javascript"
        src="http://mapv.baidu.com/build/mapv.min.js"></script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.js"></script>
<!-- touchSwipe library -->
<script src="http://labs.rampinteractive.co.uk/touchSwipe/jquery.touchSwipe.min.js"></script>
<!-- Slider Javascript file -->
<script type='text/javascript' src='./js/jquery.slideandswipe.js'></script>
<!-- my script -->
<script type="text/javascript" src="js/data.js"></script>

<script>

    //helper functions that do not depend on other modules.

    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function calc_cluster(progress) {
        return Math.floor(progress/100);
    }

    function calc_progress(overall_percentage){
        return Math.floor(overall_percentage * ids.length / 100)
    }

    function calc_percentage(p){
        return p + 6/ids.length * 100;
    }

    //todo function toListData
    function toRetListData(ids) {
        console.log(ids);
        let data = [];
        let counter = 0;
        ids.forEach(id => {
            data.push('<li>' +
                '<div style="width: 100%; margin-left: 5px">' +
                '<button class="btn btn-success btn-xs ret_checkable" style="margin-left: 60px; font-size: x-small" value='+ counter+'>'+id+'</button>' +
                '</div>' +
                '</li>');
            if (++counter === 100)
                counter = 0;
        });

        console.log(data);
        return data;
    }

    function toSimLine(poly){

        let tr = '<tr>' +

            '<td width="105px" style="padding-bottom: 1ex">' +
            '<span style="color:blue;font-weight:bold; font-size: small">path: '+counter_line+ '</span>' +
            '</td>' +
            '<td width = "135px" style="padding-bottom: 1ex">' +
            '<button  class="btn btn-success btn-xs path_checkable" style="font-size: x-small" value="'+ counter_line +'">on display</button>' +
            '</td>'+
            '<td width = "50px" style="padding-bottom: 1ex">' +
            '<input type="radio" name="sim" value="'+ counter_line + '" checked>' +
            '</td>' +
            '</tr>';

        return tr;
    }

    function toComline(poly){

        let tr = '<tr>' +
            '<td width="100px" style="padding-bottom: 0.5ex">' +
            '<span style="color:blue;font-weight:bold; font-size: small">path: '+counter_line+ '</span>' +
            '</td>' +
            '<td width="80px" style="padding-bottom: 0.5ex">' +
            '<button  class="btn btn-success btn-xs path_checkable" style="font-size: x-small" value="'+ counter_line +'">on display</button>' +
            '</td>'+
            '<td width="80px" style="padding-bottom: 0.5ex">' +
            '<button  class="btn btn-primary btn-xs state_strict" style="font-size: x-small" value="'+counter_line+'">loose</button>' +
            '</td>'+
            '<td width="50px" style="padding-bottom: 0.5ex">' +
            '<input name="com_line" type="checkbox" value="'+ counter_line + '" checked>' +
            '</td>' +
            '</tr>';

        return tr;
    }

    // "line", "rect", "street"
    function toRect(poly){

        let tr = '<tr>' +
            '<td width="100px" style="padding-bottom: 0.5ex">' +
            '<span style="color:blue;font-weight:bold; font-size: small">window: '+counter_rect+ '</span>' +
            '</td>' +
            '<td width="80px" style="padding-bottom:  0.5ex">' +
            '<button  class="btn btn-success btn-xs rect_checkable" style="font-size: x-small" value="'+ counter_rect +'">on display</button>' +
            '</td>'+
            '<td width="80px" style="padding-bottom: 0.5ex">' +
            '<button  class="btn btn-secondary btn-xs" style="font-size: x-small" disabled>NaN</button>' +
            '</td>'+
            '<td width="50px" style="padding-bottom:  0.5ex">' +
            '<input  type="checkbox" name="com_rect" value="'+ counter_rect + '" checked>' +
            '</td>' +
            '</tr>';

        return tr;
    }

    function toStreetName(name){

        let tr = '<tr>' +
            '<td width="100px" style="padding-bottom: 0.5ex">' +
            '<span style="color:blue;font-weight:bold; font-size: small">'+name+'</span>' +
            '</td>' +
            '<td width="80px" style="padding-bottom: 0.5ex">' +
            '<button class="btn btn-secondary btn-xs" style="font-size: x-small" value="'+ name +' disabled">NaN</button>' +
            '</td>' +
            '<td width="80px" style="padding-bottom: 0.5ex">' +
            '<button  class="btn btn-primary btn-xs state_strict" style="font-size: x-small" value="'+ name +'">loose</button>' +
            '</td>'+
            '<td width="50px" style="padding-bottom: 0.5ex">' +
            '<input type="checkbox" name="com_st" value="'+ name + '" checked>' +
            '</td>' +
            '</tr>';

        return tr;
    }

    //todo set clickable
    function setClickable(){

        $('.path_checkable').click((e)=>{
            let btn = $(e.target);
            let temp = btn.attr("value");
            let index = parseInt(temp);
            console.log(index);
            if( line_polygons[index].isVisible()){
                line_polygons[index].hide();
                line_label[index].hide();
                btn.text('on hide');
                btn.addClass('btn-secondary').removeClass('btn-success');
                let temp1 = $('.path_checkable[value='+ temp +']');
                temp1.text('on hide');
                temp1.addClass('btn-secondary').removeClass('btn-success');
            }
            else{
                line_polygons[index].show();
                line_label[index].show();
                btn.text('on display');
                let temp1 = $('.path_checkable[value='+ temp +']');
                temp1.text('on display');
                temp1.addClass('btn-success').removeClass('btn-secondary');
            }
        });

        $('.rect_checkable').click((e)=>{
            let btn = $(e.target);
            let index = parseInt(btn.attr("value"));

            if( rect_polygons[index].isVisible()){
                console.log("hide" + index+"th button");

                rect_polygons[index].hide();
                rect_label[index].hide();
                btn.text('on hide');
                btn.addClass('btn-secondary').removeClass('btn-success');
            }
            else{
                console.log("show "+index+"th button");

                rect_polygons[index].show();
                rect_label[index].show();
                btn.text('on display');
                btn.addClass('btn-success').removeClass('btn-secondary');
            }
        });

        $('.state_strict').click((e)=>{
            let btn = $(e.target);

            if (btn.text()==='loose'){
                btn.text('strict');
            } else{
                btn.text('loose');
            }
        })
    }

    function simChange(val){
        if (val === "LCSS" || val === "EDR")
            $('#epsilonWrapper').show();
        else
            $('#epsilonWrapper').hide();
    }

    //display news
    function badInfo( content) {
        let element = $('#info');
        element.removeClass("alert-success").addClass("alert-warning")
        element.text(content);
        element.show();
    }

    function goodInfo( content){
        let element = $('#info');
        element.removeClass("alert-warning").addClass("alert-success")
        element.text(content);
        element.show();
    }

    $(document).ready(() => {

        //todo definition of function

        function optionsForSim(){
            $('#div_showMapped').show();
            $('#div_showRaw').show();
            $('#div_hideRet').show();
            $('#div_showRep').hide();
        }

        function optionsForBool(hasPath){
            $('#div_showRep').show();
            $('#div_hideRet').show();

            $('#hideRet').prop('checked', true);
            hide = true;

            if (hasPath) {
                $('#div_showMapped').show();
                $('#div_showRaw').show();
            }else{
                $('#div_showMapped').hide();
                $('#div_showRaw').hide();
            }
        }

        function clearAll() {
            clearRetPanel();
            clusterize_sim.clear();
            clusterize_com.clear();

            //clear state
            counter_line = 0;
            counter_st = 0;
            counter_rect = 0;

            line_label = [];
            line_polygons = [];
            rect_label = [];
            rect_polygons = [];

            map.clearOverlays();
            if (lineLayer) {
                lineLayer.destroy();
                lineLayer = undefined;
                animationLayer.destroy();
                animationLayer = undefined;
            }

            if (singleLineLayer) {
                singleLineLayer.destroy();
                singleAnimationLayer.destroy();
                singleLineLayer = undefined;
                singleAnimationLayer = undefined;
            }
        }

        function clearRetPanel(){
            curClusterId = 0;
            ids = [];
            map_data = [];
            slot = [];
            clusterize_ret.clear();
            $('#div_hideRet').hide();
            $('#div_showRaw').hide();
            $('#div_showMapped').hide();
            $('#div_showRep').hide();


            let infoElement = $('#info');
            infoElement.text("");
            infoElement.hide();
            first = true;
            hide = false;
        }

        function downloadFullTraj(curCluster, _display, hide) {

            if (slot[curCluster]) return;
            console.log("download trajectory for cluster: "+curCluster);
            slot[curCluster] = true;
            let table_max_idx = ids.length - 1;
            let begin_idx = curCluster * 100;
            let end_idx = (curCluster+1) * 100 - 1;
            console.log("begin_idx: "+begin_idx);
            if (begin_idx >= table_max_idx) return;
            if (table_max_idx < end_idx)
                end_idx = table_max_idx;

            let url = URL_PREFIX + TRAJ_ID_API;

            let arr = [];

            for (let i = begin_idx; i <= end_idx; i++) {
                arr.push(ids[i]);
            }

            $.ajax({
                url: url,
                data: {
                    idSet : JSON.stringify(arr),
                    city : curCity
                },
                dataType:'json',
                cache: false,
                type: "GET",
                success: function(res) {
                    map_data[curCluster] = res;
                    console.log("find map_data for cluster: "+ curCluster);
                    if (_display) {
                        display(hide);
                        displayed = curCluster;
                    }
                },

                error: function(xhr) {
                    console.log("cannot download cluster: "+clusterize_ret+" . Server unavailable");
                }
            });
        }

        function displayOnInit(trajs, slice, num){
            //random select 100 trajectories
            if (slice) {
                let rand = getRandomInt(0, 1);
                let begin = rand * 100;
                let end = (rand + 2) * 100;
                trajs = trajs.slice(begin, end);
            }


            let times = [];
            for (let k = 0; k < num; k++){
                let traj = trajs[k];
                let coordsArr = traj.geometry.coordinates;
                let i;
                let random1 = getRandomInt(0,20);
                let random2 = 10;
                if (k < num / 2) {
                    for (i = 0; i < coordsArr.length; i++) {
                        times.push({
                            geometry: {
                                type: 'Point',
                                coordinates: [coordsArr[i][0], coordsArr[i][1]]
                            },
                            count: 1,
                            time: i+random1
                        })
                    }
                }else {
                    let m = random2;
                    for (i = coordsArr.length - 1; i >= 0; i--) {
                        times.push({
                            geometry: {
                                type: 'Point',
                                coordinates: [coordsArr[i][0], coordsArr[i][1]]
                            },
                            count: 1,
                            time: m++
                        })
                    }
                }
            }

            if (!lineLayer) {
                trajData = new mapv.DataSet(trajs);
                timeData = new mapv.DataSet(times);
                lineLayer = new mapv.baiduMapLayer(map, trajData, mapv_option_line_light_purple);
                animationLayer = new mapv.baiduMapLayer(map, timeData, mapv_option_dot_animation);
            }else{
                trajData.set(trajs);
                timeData.set(times);
            }

            //timeData.set(); // ‰øÆÊîπÊï∞ÊçÆ
            // lineLayer.show(); // ÊòæÁ§∫ÂõæÂ±Ç
            // animationLayer.show();
            // mapvLayer.hide(); // Âà†Èô§ÂõæÂ±Ç
        }

        function display(hide) {
            let trajs = map_data[curClusterId];
            let times = [];
            console.log(trajs);
            trajs.forEach(traj =>{

                let coordsArr = traj.geometry.coordinates;
                let i;
                for( i = 0; i < coordsArr.length; i ++){
                    times.push({
                        geometry: {
                            type: 'Point',
                            coordinates: [coordsArr[i][0], coordsArr[i][1]]
                        },
                        count:1,
                        time: i
                    })
                }
            });

            if (!lineLayer) {
                trajData = new mapv.DataSet(trajs);
                timeData = new mapv.DataSet(times);
                lineLayer = new mapv.baiduMapLayer(map, trajData, mapv_option_line_light_purple);
                animationLayer = new mapv.baiduMapLayer(map, timeData, mapv_option_dot_animation_init);
            }else{
                trajData.set(trajs);
                timeData.set(times);
            }

            if (hide){
                lineLayer.hide();
                animationLayer.hide();
                hide = true;
            }else{
                lineLayer.show();
                animationLayer.show();
                hide = false;
            }
        }
        
        function displayReprep(data){

            let trajs = data;
            let times = [];
            console.log(trajs);
            trajs.forEach(traj =>{

                let coordsArr = traj.geometry.coordinates;
                let i;
                for( i = 0; i < coordsArr.length; i ++){
                    times.push({
                        geometry: {
                            type: 'Point',
                            coordinates: [coordsArr[i][0], coordsArr[i][1]]
                        },
                        count:1,
                        time: i
                    })
                }
            });

            if (!reprepLayer) {
                reprepData = new mapv.DataSet(trajs);
                reprepAniData = new mapv.DataSet(times);
                reprepLayer = new mapv.baiduMapLayer(map, reprepData, mapv_option_line_single);
                reprepAniLayer = new mapv.baiduMapLayer(map, reprepAniData, mapv_option_single_line_dot_animation);
            }else{
                reprepData.set(trajs);
                reprepAniData.set(times);
            }

            if (lineLayer) {
                hide = true;
                lineLayer.hide();
                animationLayer.hide();
            }

            if (singleLineLayer) {
                singleLineLayer.hide();
                singleAnimationLayer.hide();
            }
            reprepLayer.show();
            reprepAniLayer.show();
        }

        function displaySingle(index) {

            // mapV API
            // draw retrieved trajecory map_data on map
            console.log("display map data on cluster: "+curClusterId);
            console.log("index: "+ index);
            let trajs;

            trajs = map_data[curClusterId];
            let temp = [];
            temp.push(trajs[index]);
            trajs = temp;
            let times = [];

            let coordsArr = trajs[0].geometry.coordinates;
            let i;
            for (i = 0; i < coordsArr.length; i++) {
                times.push({
                    geometry: {
                        type: 'Point',
                        coordinates: [coordsArr[i][0], coordsArr[i][1]]
                    },
                    count: 1,
                    time: i
                })
            }

            if (!singleLineLayer) {

                singleTrajData = new mapv.DataSet(trajs);
                singleTimeData = new mapv.DataSet(times);
                singleLineLayer = new mapv.baiduMapLayer(map, singleTrajData, mapv_option_line_single);
                singleAnimationLayer = new mapv.baiduMapLayer(map, singleTimeData, mapv_option_single_line_dot_animation);
            }else{
                singleTrajData.set(trajs);
                singleTimeData.set(times);
            }

            hide = true;
            lineLayer.hide();
            animationLayer.hide();
            $('#hideRet').prop('checked', true);

            if (reprepLayer) {
                reprepLayer.hide();
                reprepAniLayer.hide();
                $('#showRep').prop('checked', false);
            }
            
            singleLineLayer.show();
            singleAnimationLayer.show();

            //rawLayer.show();
            //mappedLayer.show();
        }

        function makeRaw(coorArrays) {

            let trajs = [];

            coorArrays.forEach((coorArray) => {
                let geo = [];
                coorArray.forEach(coor => {
                    geo.push([coor.lng, coor.lat])
                });

                //gen mapVformat
                trajs.push({
                    geometry: {
                        type: "LineString",
                        coordinates: geo
                    },
                });
            });

            if (!rawLayer) {
                rawData = new mapv.DataSet(trajs);
                rawLayer = new mapv.baiduMapLayer(map, rawData, mapv_option_line_raw);
            }else{
                rawData.set(trajs);
            }
            rawLayer.hide();
        }

        function makeMapped(coorArrays) {

            let trajs = [];

            coorArrays.forEach((coorArray) => {
                let geo = [];
                coorArray.forEach(coor => {
                    geo.push([coor.lng, coor.lat])
                });

                //gen mapVformat
                trajs.push({
                    geometry: {
                        type: "LineString",
                        coordinates: geo
                    },
                });
            });

            if (!mappedLayer) {
                console.log(trajs);
                mappedData = new mapv.DataSet(trajs);
                mappedLayer = new mapv.baiduMapLayer(map, mappedData, mapv_option_line_matched);
            }else{
                mappedData.set(trajs);
            }
            mappedLayer.hide();
        }

        //todo similarity scroll area
        let clusterize_sim = new Clusterize({
            scrollId: 'topK_scrollArea',
            contentId: 'topK_contentArea',
            rows_in_block:15,
            blocks_in_cluster:2,
        });

        //todo combination scroll area
        let clusterize_com = new Clusterize({
           scrollId: 'combined_scrollArea',
           contentId: 'combined_contentArea',
           rows_in_block:15,
           blocks_in_cluster:2,
        });


        //todo result scroll area
        let displayed;
        let clusterize_ret = new Clusterize({
            scrollId: 'ret_scrollArea',
            contentId: 'ret_contentArea',
            rows_in_block:100,          // displayOnInit 100 records each time
            blocks_in_cluster:2,
            callbacks:{
                scrollingProgress:(percentage)=>{

                    // 1. displayOnInit progress bar
                    let percentageForPBar = calc_percentage(percentage);
                    let progress = calc_progress(percentage);
                    curClusterId = calc_cluster(progress);

                    $('#progressBar').css('width', percentageForPBar+'%')
                        .attr('aria-valuenow', percentageForPBar)
                        .text(percentageForPBar.toFixed(2)+"%");

                    // no need to require trajectories if the stuff has been cached on client side
                    if (!slot[curClusterId])
                        downloadFullTraj(curClusterId, false, false);

                    if (displayed !== curClusterId){
                        if (map_data[curClusterId]) {
                            display(false);
                            displayed = curClusterId;
                        }
                    }

                    if ( !slot[curClusterId + 1]) {
                        if (maxClusterId !== curClusterId) {
                            downloadFullTraj(curClusterId + 1, false, false);
                        }
                    }

                    if (reprepLayer) {

                        if ($('#showRep').is(':checked')) {
                            $('#showRep').prop('checked', false);
                            reprepLayer.hide();
                            reprepAniLayer.hide();
                        }
                    }


                    if(hide){
                        lineLayer.show();
                        animationLayer.show();
                        if (singleLineLayer) {
                            singleLineLayer.hide();
                            singleAnimationLayer.hide();
                        }
                        hide = false;
                        $('#hideRet').prop('checked', false); // Unchecks it
                    }
                },

                clusterChanged: ()=>{
                    if (firstTime){
                        firstTime = false;
                        return;
                    }

                    let progress = calc_progress(clusterize_ret.getScrollProgress());
                    if (progress ===0 ) return;

                    curClusterId = calc_cluster(progress);;
                    console.log("cluster changed. cur cluster id: "+curClusterId);

                    if(map_data[curClusterId]) {
                        display(false);
                        displayed = curClusterId;
                    }

                    $('.ret_checkable').click((e)=>{
                        let index = parseInt($(e.target).attr("value"));
                        console.log("set checkable");
                        displaySingle(index);
                    });

                },
            }
        });

        $('.nav').slideAndSwipe();
        $('.retPanel').hide();
        $("#btn_nav").click();

        $.ajax({
            url: URL_PREFIX+INIT_FILE,
            dataType:'json',
            cache: false,
            type: "GET",
            success: function(res) {
                displayOnInit(res, true, 100);
            },

            error: function(xhr) {
                console.log("error message: ");
                console.log(xhr);
            }
        });

        for (let i = 0; i <= 3; i++) {
            let curBtn = $('#btn' + i);
            curBtn.click(() => {

                let input = $('#input');
                if (i === SIMILARITY_SEARCH)
                    input.attr("placeholder", "draw a path for current query type");
                else if(i === RANGE_SEARCH)
                    input.attr("placeholder", "draw a window for current query type");
                else
                    input.attr("placeholder", "draw a path or input a street name for current query type");
                input.val("");

                if (curBtnState !== i) {
                    $('#btn'+curBtnState).removeClass("btn-primary").addClass("btn-secondary");
                    curBtn.removeClass("btn-secondary").addClass("btn-primary");
                    curBtnState = parseInt(curBtn.val());
                    if (curBtnState === SIMILARITY_SEARCH || curBtnState === RANGE_SEARCH){
                        $('#input').prop('disabled',true)
                    } else {
                        $('#input').prop('disabled',false)

                    }
                    console.log(curBtn.val())
                }

                $('#info').hide();
            });
        }

        $('#btn0').click();

        // baidu API
        let map = new BMap.Map("map");    // ÂàõÂª∫MapÂÆû‰æã
        map.centerAndZoom(new BMap.Point(-8.594061, 41.162726), 14);  // ÂàùÂßãÂåñÂú∞Âõæ,ËÆæÁΩÆ‰∏≠ÂøÉÁÇπÂùêÊ†áÂíåÂú∞ÂõæÁ∫ßÂà´
        map.enableScrollWheelZoom(true); // ÂºÄÂêØÈº†Ê†áÊªöËΩÆÁº©Êîæ
        let bottom_right_navigation = new BMap.NavigationControl({
            anchor: BMAP_ANCHOR_BOTTOM_RIGHT,
            offset: new BMap.Size(10, 90)
        });
        map.addControl(bottom_right_navigation);
        // map.setMapStyle({style: 'light'});
        map.setMapStyle({styleJson:mapStyle});

        let drawer = new BMapLib.DrawingManager(map, {
            isOpen: false,                          // disable drawing mode
            enableDrawingTool: true,                // displayOnInit tool bar
            drawingToolOptions: {
                anchor: BMAP_ANCHOR_TOP_RIGHT,      // position of the tool bar
                offset: new BMap.Size(130, 60),        // offset from the position
                scale: 0.8,
                drawingModes: [                    // functions on tool bar
                    // BMAP_DRAWING_MARKER,
                    // BMAP_DRAWING_CIRCLE,
                    BMAP_DRAWING_POLYLINE,
                    // BMAP_DRAWING_POLYGON,
                    BMAP_DRAWING_RECTANGLE
                ]
            },
            polylineOptions: pathStyle,
            rectangleOptions: rectStyle
        });

        //todo change city
        $('#cityMenu').text("City: Porto");
        $('.dropdown .dropdown-menu .dropdown-item').click(function(){
            let text = $(this).text();
            if (text === "Beijing"){
                if (curCity !== BEIJING) {
                    clearAll();
                    map.centerAndZoom(new BMap.Point(116.3975, 39.9087), 12);  // ÂàùÂßãÂåñÂú∞Âõæ,ËÆæÁΩÆ‰∏≠ÂøÉÁÇπÂùêÊ†áÂíåÂú∞ÂõæÁ∫ßÂà´
                    curCity = BEIJING;
                    $.ajax({
                        url: URL_PREFIX+BEIJING_FILE,
                        dataType:'json',
                        cache: false,
                        type: "GET",
                        success: function(res) {
                            displayOnInit(res, false, 60);
                        },

                        error: function(xhr) {
                            console.log("error message: ");
                            console.log(xhr);
                        }
                    });
                }
            }else if(text === "Porto"){
                if (curCity !== PORTO) {
                    clearAll();
                    curCity = PORTO;
                    map.centerAndZoom(new BMap.Point(-8.594061, 41.162726), 13);  // ÂàùÂßãÂåñÂú∞Âõæ,ËÆæÁΩÆ‰∏≠ÂøÉÁÇπÂùêÊ†áÂíåÂú∞ÂõæÁ∫ßÂà´
                    $.ajax({
                        url: URL_PREFIX+PORTO_FILE,
                        dataType:'json',
                        cache: false,
                        type: "GET",
                        success: function(res) {
                            displayOnInit(res, false, 60);
                        },

                        error: function(xhr) {
                            console.log("error message: ");
                            console.log(xhr);
                        }
                    });
                }
            }
            console.log(curCity);
            $('#cityMenu').text("City: " + text);
        });

        //todo complete line
        let lineComplete = function(line){

            let point = line.getPath()[0];
            let opts = {
                position : point,
            };
            let label = new BMap.Label("path: "+line_polygons.length, opts);
            label.setStyle({
                color : "red",
                fontSize : "15px",
                height : "0px",
                width: "0px"
            });
            map.addOverlay(label);

            line_label.push(label);
            line_polygons.push(line);

            clusterize_sim.prepend([toSimLine(line)]);
            clusterize_com.prepend([toComline(line)]);

            setClickable();

            counter_line++;
        };

        //todo complete other
        let rectComplete = function (rect) {

            let point = new BMap.Point((rect.getPath()[0].lng + rect.getPath()[2].lng)/2, (rect.getPath()[0].lat + rect.getPath()[2].lat) / 2);
            let opts = {
                position : point,
            };
            let label = new BMap.Label("window: "+rect_polygons.length, opts);
            label.setStyle({
                color : "red",
                fontSize : "15px",
                height : "0px",
                width: "0px"
            });
            map.addOverlay(label);

            rect_label.push(label);
            rect_polygons.push(rect);
            clusterize_com.prepend([toRect(rect)]);

            setClickable();

            counter_rect++;
        };

        drawer.addEventListener("polylinecomplete", lineComplete);

        drawer.addEventListener("rectanglecomplete", rectComplete);

        //todo add street name button
        $('#btn_street').click(()=>{
            clusterize_com.prepend([toStreetName($('#input_street').val())]);
            setClickable();

        });

        $('#showRaw').change(function(){
            if($(this).is(':checked')) {
                rawLayer.show();
            } else {
                rawLayer.hide();
            }
        });

        $('#showMapped').change(function(){
            if($(this).is(':checked')) {
                mappedLayer.show();
            } else {
                mappedLayer.hide();
            }
        });
        
        $('#showRep').change(function(){
            if($(this).is(':checked')){
                reprepLayer.show();
                reprepAniLayer.show();
                if (!hide) {
                    console.log("there")
                    $('#hideRet').prop('checked', true); // Unchecks it
                    $('#hideRet').trigger("change");
                }
            }else{
                reprepLayer.hide();
                reprepAniLayer.hide();
            }
        });

        $('#hideRet').change(function(){
            if($(this).is(':checked')) {
                if (singleLineLayer) {
                    singleLineLayer.hide();
                    singleAnimationLayer.hide();
                }
                lineLayer.hide();
                animationLayer.hide();
                hide = true;
            } else {
                hide = false;
                lineLayer.show();
                animationLayer.show();
            }
        });


        $("#btnClear").click(()=>{
            clearAll();
        });

        //todo sim search button
        $("#sim_search").click(()=>{

            let url = URL_PREFIX + API_SIM;
            console.log(url);

            let data;

            let idx = parseInt($('input[name=sim]:checked').val());
            console.log("index: " + idx);
            let temp = line_polygons[idx].getPath();

            let path = "[";
            temp.forEach((item) => {
                path += "[" + item.lat + "," + item.lng + "],"
            });
            path = path.substr(0, path.length - 1);
            path += "]";

            console.log("line: " + path);

            let start = $('#start_time').val();
            let end = $('#end_time').val();

            let k = parseInt($('#input_k').val());

            let epsilon = $('#input_epsilon').val();

            let simFunc = ($('.simGroup option:selected').val());

            data = {
                query: path,
                k: k,
                measure: simFunc,
                epsilon: epsilon,
                start: start,
                end: end,
                city: curCity
            };

            console.log(data);

            goodInfo("The query is under processing, please wait...");

            $.ajax({
                url: url,
                data: data,
                dataType:'json',
                cache: false,
                type: "GET",
                success: function(res) {
                    // clearAll();
                    clearRetPanel();

                    $('.path_checkable').each(function(i, obj){
                        let btn = $(this);
                        if (btn.text() === "on display"){
                            let temp = btn.attr("value");
                            let index = parseInt(temp);
                            console.log(index);
                            line_polygons[index].hide();
                            line_label[index].hide();
                            btn.text('on hide');
                            btn.addClass('btn-secondary').removeClass('btn-success');
                        }
                    });

                    console.log(res);
                    if (!res.formatCorrect) {
                        badInfo("Query is not in the right format. Please do double check!");
                        return;
                    }

                    let retObj = res.retObj;
                    if (!retObj.mappingSucceed){
                        badInfo("Query can not be properly map-matched to road network!")
                        return;
                    }

                    let retSize = parseInt(retObj.retSize);
                    if ( retSize === 0){
                        goodInfo("no trajectory meets the requirement");
                        return;
                    }

                    if (retSize > 100){
                        goodInfo("There are "+retSize+" of qualified trajectories found, 100 of them are displayed.");
                    } else{
                        goodInfo("There are "+retSize+" of qualified trajectories found.")
                    }

                    ids = retObj.ids;
                    console.log("ids: "+ids);
                    for (let i = 0; i < ids.length; i++)
                        slot[i] = false;

                    optionsForSim();
                    makeRaw([retObj.rawTrajectory]);
                    makeMapped([retObj.mappedTrajectory]);

                    if ($('#showRaw').is(':checked')) rawLayer.show();
                    if ($('#showMapped').is(':checked')) mappedLayer.show();

                    console.log(res.queryType);
                    ids.reverse();


                    clusterize_ret.append(toRetListData(ids));

                    downloadFullTraj(curClusterId, true, false);
                    maxClusterId = calc_cluster(ids.length - 1);
                    $("#retSize").text(ids.length);
                    $(".retPanel").show();
                    $('#hideRet').prop('checked', false);

                    if (reprepLayer){
                        reprepLayer.hide();
                        reprepAniLayer.hide();
                    }

                    $('.ret_checkable').click((e)=>{
                        let index = parseInt($(e.target).attr("value"));
                        console.log("index: "+index);
                        displaySingle(index);
                    });
                },
                error: function(xhr) {
                    badInfo("server unavailable");
                }
            });
        });

        $('#bool_search').click(()=>{

            let url = URL_PREFIX + API_MULTI;
            console.log(url);

            let items = [];
            let start = $('#start_time').val();
            let end = $('#end_time').val();

            let hasQuery = false;

            $('input[type="checkbox"][name="com_line"]:checked').map(function() {
                hasQuery = true;

                let idx = parseInt($(this).val());
                let temp = line_polygons[idx].getPath();

                let path = "[";
                temp.forEach((item) => {
                    path += "[" + item.lat + "," + item.lng + "],"
                });
                path = path.substr(0, path.length - 1);
                path += "]";

                let type;
                if ( $('.state_strict[value="'+ idx +'"]').text()==='loose'){
                    type = 'PQ';
                }else{
                    type = 'SPQ';
                }

                items.push({
                    type:type,
                    query: path
                })
            });

            let selectedWindow_index_set = new Set();
            $('input[type="checkbox"][name="com_rect"]:checked').map(function() {
                hasQuery = true;

                let idx = parseInt($(this).val());
                selectedWindow_index_set.add(idx);
                let temp = rect_polygons[idx].getPath();

                let temp1 = [
                    temp[0],
                    temp[2]
                ];

                let window = "[";
                temp1.forEach((item) => {
                    window += "[" + item.lat + "," + item.lng + "],"
                });
                window = window.substr(0, window.length - 1);
                window += "]";

                console.log("idx: " + idx);
                console.log("window: " + window);
                items.push({
                    type:'RQ',
                    query: window
                })
            });

            $('input[type="checkbox"][name="com_st"]:checked').map(function() {
                hasQuery = true;

                let st_name = $(this).val();
                console.log("street name: " + st_name);
                let type;
                if ( $('.state_strict[value="'+ st_name +'"]').text()==='loose'){
                    type = 'NPQ';
                }else{
                    type = 'NSPQ';
                }
                items.push(({
                    type:type,
                    query: st_name
                }))
            });

            let data = {
                items: JSON.stringify(items),
                start: start,
                end: end,
                city: curCity
            };

            if (!hasQuery){
                badInfo("please select one query at least!");
                return;
            }

            goodInfo("The query is under processing, please wait...");

            $.ajax({
                url: url,
                data: data,
                dataType:'json',
                cache: false,
                type: "GET",
                contentType:"application/json",
                success: function(res) {

                    clearRetPanel();

                    console.log("result: " + res);
                    ids = JSON.parse(res.ids);
                    let rets = JSON.parse(res.arr);
                    let mapvCluster = JSON.parse(res.cluster);
                    console.log("result trajectory ids: "+ ids);
                    console.log("mapv cluster size: "+mapvCluster.length);


                    //hide non query paths and windows
                    $('.path_checkable').each(function(i, obj){
                        let btn = $(this);
                        if (btn.text() === "on display"){
                            let temp = btn.attr("value");
                            let index = parseInt(temp);
                            console.log(index);
                            line_polygons[index].hide();
                            line_label[index].hide();
                            btn.text('on hide');
                            btn.addClass('btn-secondary').removeClass('btn-success');
                        }
                    });

                    $('.rect_checkable').each(function(i, obj){
                       let btn = $(this);
                       let index = parseInt(btn.attr("value"));

                       if (!selectedWindow_index_set.has(index) && btn.text() === "on display"){
                           btn.click();
                       }
                    });

                    let hasPathQ = false;
                    let raw = [];
                    let mapped = [];

                    //construct result arrays
                    rets.forEach((ret) => {
                        if (ret.queryType !== "RQ") {

                                hasPathQ = true;

                            if (ret.retObj.mappingSucceed){
                                raw.push(ret.retObj.rawTrajectory);
                                mapped.push(ret.retObj.mappedTrajectory);
                            }

                        }
                    });

                    console.log("result trajectory size: " + ids.length);

                    if (hasPathQ) {
                        makeRaw(raw);
                        makeMapped(mapped);
                        $("#nonRQ").show();

                        if ($('#showRaw').is(':checked')) rawLayer.show();
                        if ($('#showMapped').is(':checked')) mappedLayer.show();

                    }

                    if (ids.length === 0) {
                        clearRetPanel();
                        goodInfo("no trajectories meet the requirement");
                        return;
                    }else if (ids.length > 100){
                        goodInfo("There are "+ids.length+" of qualified trajectories found, 100 of them are displayed.");
                    } else{
                        goodInfo("There are "+ids.length+" of qualified trajectories found.")
                    }

                    let temp = Math.ceil(ids.length / 100)+1;
                    for (let i = 0; i < temp; i++)
                        slot[i] = false;

                    clusterize_ret.append(toRetListData(ids));
                    console.log("append ids to listView");

                    maxClusterId = calc_cluster(ids.length - 1);
                    $("#retSize").text(ids.length);
                    $(".retPanel").show();

                    optionsForBool(hasPathQ);
                    if (mapvCluster.length === 0){
                        $('#showRep').prop('checked', false); // Unchecks it
                        $('#div_showRep').hide();
                        $('#hideRet').prop('checked', false);
                        downloadFullTraj(curClusterId, true, false);
                    }else{
                        //display reprepsentative.
                        displayReprep(mapvCluster);
                        $('#showRep').prop('checked', true); // Unchecks it
                        $('#hideRet').prop('checked', true); // Unchecks it
                        downloadFullTraj(curClusterId, true, true);
                    }

                    $('.ret_checkable').click((e)=>{
                        let index = parseInt($(e.target).attr("value"));
                        displaySingle(index);
                    });
                },
                error: function(xhr) {
                    console.log(xhr);
                    badInfo("server unavailable");
                }
            });
        })
    });
</script>
</body>
</html>